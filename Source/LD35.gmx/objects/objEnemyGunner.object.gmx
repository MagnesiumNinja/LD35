<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle_Normal</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>50</depth>
  <persistent>0</persistent>
  <parentName>objEnemyEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

enum GunnerAIState
{
    IDLE,
    MOVE,
    ATTACK
}


// CONSTANTS //

RECALCULATE_TIME = 10;
MAX_HP = 3;
MOVE_SPEED = 2;

AGGRO_DIS = 750;
VIEW_ANGLE = 45;
CHARGE_TIME = 60;
ATTACK_TIME = 30;

NUM_BLOOD_SPLATTERS = 3;

MOVE_RANGE = 96;
FRIC = 0.4;
KNOCKBACK_SPEED = 3;


// VARIABLES //

hp = MAX_HP;
recalcTime = RECALCULATE_TIME;
type = EnemyType.GUNNER;
target = objPlayer;

state = GunnerAIState.IDLE;
chargeTime = CHARGE_TIME;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (!dead)
{
    switch(state)
    {
        case GunnerAIState.IDLE:
        {
            var tarAngle = point_direction(x, y, target.x, target.y);
            
            if (distance_to_object(target) &lt; AGGRO_DIS &amp;&amp; isAngleBetween(tarAngle, image_angle - VIEW_ANGLE, image_angle + VIEW_ANGLE) &amp;&amp; !collision_line(x, y, target.x, target.y, objCollide, false, true))
            {
                // Line of sight
                state = PhantomAIState.MOVE;
            }
        
            break;    
        }
    
    
        case GunnerAIState.MOVE:
        {
            if (followingPath)
            {
                if (path_index = -1)
                {
                    followingPath = false;
                    hasPath = false;
                    
                    state = GunnerAIState.ATTACK;
                }
            }
            else
            {
                if (hasPath)
                {
                    path_start(path, MOVE_SPEED, path_action_stop, true);
                    followingPath = true;
                }
                else
                {
                    // Find a new place to stand
                    do
                    {
                        destX = x + random_range(-MOVE_RANGE, MOVE_RANGE);
                        destY = y + random_range(-MOVE_RANGE, MOVE_RANGE);
                    }
                    until(!collision_line(destX, destY, objPlayer.x, objPlayer.y, objCollide, false, true));
                    
                    findPath = true;
                }
            }
            
            break;
        }
        
        case GunnerAIState.ATTACK:
        {   
            path_end();
            
            if (collision_line(x, y, target.x, target.y, objCollide, false, true))
            {
                state = PhantomAIState.IDLE;
            }
            else
            {
                if (chargeTime &gt; 0)
                    chargeTime--;
                
                if (chargeTime == ATTACK_TIME)
                {
                    // Attack
                    var attack = instance_create(x, y, objGunnerGunshot);
                    attack.angle = point_direction(x, y, target.x, target.y);
                    attack.target = target;
                    attack.par = id;
                }
                else if (chargeTime == 0)
                {
                    chargeTime = CHARGE_TIME;
                    state = PhantomAIState.IDLE;
                }
            }
            break;
        }
    }
}
else
{
    path_end();            
    
    // Slow down
    hspd = approach(hspd, 0, FRIC);
    vspd = approach(vspd, 0, FRIC);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEAD event

path_end();

objPlayer.changing = true;
objPlayer.changeTarget = id;

if (!(hitX == 0 &amp;&amp; hitY == 0))
{
    var kbAngle = point_direction(hitX, hitY, x, y);
    hspd = lengthdir_x(KNOCKBACK_SPEED, kbAngle);
    vspd = lengthdir_y(KNOCKBACK_SPEED, kbAngle);
}

// generate blood splatters
for (var i = 0; i &lt; NUM_BLOOD_SPLATTERS; i++)
{
    var dashPart = instance_create(x, y, objBloodSplatter);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_white, fowAlpha);

draw_set_alpha(fowAlpha);
draw_set_color(c_red);

draw_line(x, y, x + lengthdir_x(128, image_angle - VIEW_ANGLE), y + lengthdir_y(128, image_angle - VIEW_ANGLE));
draw_line(x, y, x + lengthdir_x(128, image_angle + VIEW_ANGLE), y + lengthdir_y(128, image_angle + VIEW_ANGLE));

draw_set_alpha(1);
draw_set_color(c_white);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
